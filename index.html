<!DOCTYPE html>
<html>
<head>
    <title>Image Viewer</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <style>
        body { 
            margin: 0;
            overflow: hidden;
            background: #000;
        }
    </style>
</head>
<body>
    <script>
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Shader code
        const dissolveVertexShader = `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;

        const dissolveFragmentShader = `
            uniform sampler2D tDiffuse;
            uniform float dissolve;
            uniform float pixelSize;
            varying vec2 vUv;

            float random(vec2 co) {
                return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
            }

            void main() {
                vec2 pixelatedUV = floor(vUv * pixelSize) / pixelSize;
                float r = random(pixelatedUV);
                float fallStart = r * 0.3;
                float fallProgress = max(0.0, (dissolve - fallStart) / (1.0 - fallStart));
                float gravity = fallProgress * fallProgress * 0.0001;
                vec2 offsetUV = vUv;
                offsetUV.y -= gravity;
                vec4 color = texture2D(tDiffuse, offsetUV);
                float fade = 1.0 - fallProgress;
                if(offsetUV.y < 0.0 || offsetUV.y > 1.0) {
                    fade = 0.0;
                }
                float visibility = step(dissolve, r) + (1.0 - step(fallStart, dissolve)) * fade;
                gl_FragColor = vec4(color.rgb, visibility * color.a);
            }
        `;

        let currentIndex = 0;
        let isAnimating = false;
        const photoObjects = [];
        const fragments = [];
        const textureLoader = new THREE.TextureLoader();

        // Function to recursively scan the images directory
        async function getImagePaths() {
            // Define folder groups with their respective naming patterns
            const folderGroups = {
                fangAndNeo: {
                    folders: [
                        'Fang_24CT_Gold',
                        'Fang_Assassin',
                        'Fang_Blub_and_Friends',
                        'Fang_Ghost_Captain_Blue',
                        'Fang_Ghost_Captain_Green',
                        'Fang_Ghost_Captain_Red',
                        'Fang_Hyper_Pressure',
                        'Fang_King_Blub',
                        'Fang_Patrol',
                        'Fang_Royal_Blue',
                        'Fang_Rust_bucket_Blue',
                        'Fang_Rust_Bucket_Red',
                        'Fang_Rust_Bucket_Violet',
                        'Fang_Rust_bucket_Yellow',
                        'Fang_Seafoam',
                        'Neo_Shogun_24CT_Gold',
                        'Neo_Shogun_Assassin',
                        'Neo_Shogun_Blub_and_Friends',
                        'Neo_Shogun_Ghost_Captain_Blue',
                        'Neo_Shogun_Ghost_Captain_Green',
                        'Neo_Shogun_Ghost_Captain_Red',
                        'Neo_Shogun_Hyper_Pressure',
                        'Neo_Shogun_King_Blub',
                        'Neo_Shogun_Patrol',
                        'Neo_Shogun_Royal_Blue',
                        'Neo_Shogun_Rust_Bucket_Blue',
                        'Neo_Shogun_Rust_Bucket_Red',
                        'Neo_Shogun_Rust_Bucket_Violet',
                        'Neo_Shogun_Rust_Bucket_Yellow',
                        'Neo_Shogun_Seafoam'
                    ],
                    numbers: ['1_002', '2_001', '3_000', '4_003', '5_004', '6_005', '7_006']
                },
                thelm: {
                    folders: [
                        'THELM_Blub_and_Friends_Silver',
                        'THELM_Deep_Sea_Gold',
                        'THELM_Ghost_Captain_Blue',
                        'THELM_Ghost_Captain_Green',
                        'THELM_Helm_Blub_and_Friends_Gold',
                        'THELM_Hyper_Pressure',
                        'THELM_Hyper_Pressure_Blubsessed',
                        'THELM_Hyper_Pressure_Trifecta',
                        'THELM_Hyper_Pressure_X',
                        'THELM_King_Blub',
                        'THELM_Navy_Seal',
                        'THELM_RustBucketBlue',
                        'THELM_RustBucketRed',
                        'THELM_RustBucketViolet',
                        'THELM_RustBucketYellow'
                    ],
                    numbers: ['1_0000', '2_0001', '3_0002', '4_0003', '6_0005', '7_0006']
                }
            };

            const paths = [];

            // Generate paths for each folder group
            Object.values(folderGroups).forEach(group => {
                group.folders.forEach(folder => {
                    group.numbers.forEach(num => {
                        paths.push(`images/${folder}/${num}.png`);
                    });
                    // Add profile headshot if it's a THELM folder
                    if (folder.startsWith('THELM_')) {
                        paths.push(`images/${folder}/Profile_Headshot_0004.png`);
                    }
                });
            });

            return paths;
        }
        }
        }

        function sortImages(imageList) {
            const groupedImages = {};
            imageList.forEach(imagePath => {
                const parts = imagePath.split('/');
                const folder = parts[parts.length - 2];
                const filename = parts[parts.length - 1];
                if (!groupedImages[folder]) {
                    groupedImages[folder] = [];
                }
                groupedImages[folder].push(imagePath);
            });

            const sortedFolders = Object.keys(groupedImages).sort();

            sortedFolders.forEach(folder => {
                groupedImages[folder].sort((a, b) => {
                    const fileA = a.split('/').pop();
                    const fileB = b.split('/').pop();
                    const numA = parseInt(fileA.match(/(\d+)_/)[1]);
                    const numB = parseInt(fileB.match(/(\d+)_/)[1]);
                    if (numA !== numB) return numA - numB;
                    
                    const secA = parseInt(fileA.match(/_(\d+)\./)[1]);
                    const secB = parseInt(fileB.match(/_(\d+)\./)[1]);
                    return secA - secB;
                });
            });

            const sortedImages = [];
            sortedFolders.forEach(folder => {
                groupedImages[folder].forEach(filepath => {
                    sortedImages.push(filepath);
                });
            });

            return sortedImages;
        }

        function createPhotoPlane(texture, position) {
            const imageAspect = texture.image.width / texture.image.height;
            const displayWidth = 3;
            const displayHeight = displayWidth / imageAspect;
            
            const geometry = new THREE.PlaneGeometry(displayWidth, displayHeight);
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    tDiffuse: { value: texture },
                    dissolve: { value: 0.0 },
                    pixelSize: { value: 50.0 }
                },
                vertexShader: dissolveVertexShader,
                fragmentShader: dissolveFragmentShader,
                transparent: true
            });
            
            const plane = new THREE.Mesh(geometry, material);
            plane.position.copy(position);
            return plane;
        }

        function getPhotoPosition(t) {
            const x = t * 4;
            const z = -Math.abs(t) * 2;
            return new THREE.Vector3(x, 0, z);
        }

        function loadPhotos() {
            photoObjects.forEach(obj => scene.remove(obj));
            photoObjects.length = 0;

            const indices = [
                (currentIndex - 1 + images.length) % images.length,
                currentIndex,
                (currentIndex + 1) % images.length
            ];

            indices.forEach((index, i) => {
                textureLoader.load(images[index], (texture) => {
                    const position = getPhotoPosition(i - 1);
                    const photo = createPhotoPlane(texture, position);
                    photo.rotation.y = (i - 1) * -0.2;
                    scene.add(photo);
                    photoObjects.push(photo);
                });
            });
        }

        function animateTransition(direction) {
            if (isAnimating) return;
            isAnimating = true;

            const duration = 1.5;
            const tl = gsap.timeline({
                onComplete: () => {
                    isAnimating = false;
                    currentIndex = (currentIndex + direction + images.length) % images.length;
                    loadPhotos();
                }
            });

            // Dissolve current photo
            if (photoObjects[1]) {
                tl.to(photoObjects[1].material.uniforms.dissolve, {
                    value: 1.0,
                    duration: duration * 0.5,
                    ease: "power1.in"
                }, 0);
            }

            // Move side photos
            [photoObjects[0], photoObjects[2]].forEach((photo, i) => {
                if (!photo) return;
                
                const targetPos = getPhotoPosition((i === 0 ? 0 : 2) - 1 - direction);
                const targetRot = ((i === 0 ? 0 : 2) - 1 - direction) * -0.2;

                tl.to(photo.position, {
                    x: targetPos.x,
                    y: targetPos.y,
                    z: targetPos.z,
                    duration: duration,
                    ease: "power2.inOut"
                }, 0);

                tl.to(photo.rotation, {
                    y: targetRot,
                    duration: duration,
                    ease: "power2.inOut"
                }, 0);
            });
        }

        // Initialize
        let images = [];
        
        async function initViewer() {
            camera.position.z = 5;
            images = await getImagePaths();
            images = sortImages(images);
            loadPhotos();
        }

        // Mouse movement
        let mouseX = 0;
        let mouseY = 0;
        document.addEventListener('mousemove', (event) => {
            mouseX = (event.clientX - window.innerWidth / 2) / 200;
            mouseY = (event.clientY - window.innerHeight / 2) / 200;
        });

        // Navigation controls
        renderer.domElement.addEventListener('click', (event) => {
            const x = event.clientX / window.innerWidth;
            if (x < 0.3) navigate(-1);
            else if (x > 0.7) navigate(1);
        });

        document.addEventListener('keydown', (event) => {
            if (event.key === 'ArrowLeft') navigate(-1);
            if (event.key === 'ArrowRight') navigate(1);
        });

        function navigate(direction) {
            if (!isAnimating) {
                animateTransition(direction);
            }
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            photoObjects.forEach(photo => {
                if (photo) {
                    const baseRotationY = photo.position.x * -0.05;
                    photo.rotation.y = baseRotationY + mouseX * 0.05;
                    photo.rotation.x = mouseY * 0.05;
                }
            });

            renderer.render(scene, camera);
        }

        // Window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Start everything
        initViewer();
        animate();
    </script>
</body>
</html>