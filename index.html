<!DOCTYPE html>
<html>
<head>
  <title>Simple Image Viewer</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- Three.js and GSAP libraries -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #000;
      font-family: sans-serif;
    }
    /* Basic styling for the folder list */
    #folder-list {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 999;
      background-color: rgba(0,0,0,0.5);
      padding: 10px;
      border-radius: 5px;
    }
    #folder-list button {
      display: block;
      margin: 5px 0;
      padding: 5px 10px;
      cursor: pointer;
      background: #333;
      color: #fff;
      border: none;
      border-radius: 3px;
    }
    #folder-list button:hover {
      background: #444;
    }
  </style>
</head>
<body>
  <!-- A container for our dynamic folder list -->
  <div id="folder-list"></div>

  <script>
    /************************************************
     * 1) Basic Three.js Scene Setup
     ************************************************/
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(
      75,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    camera.position.z = 5;

    /************************************************
     * 2) Folder/Path Definitions
     ************************************************/
    // Define folder groups and naming patterns
    const folderGroups = {
      fangAndNeo: {
        folders: [
          'Fang_24CT_Gold',
          'Fang_Assassin',
          'Fang_Blub_and_Friends',
          'Fang_Ghost_Captain_Blue',
          'Fang_Ghost_Captain_Green',
          'Fang_Ghost_Captain_Red',
          'Fang_Hyper_Pressure',
          'Fang_King_Blub',
          'Fang_Patrol',
          'Fang_Royal_Blue',
          'Fang_Rust_bucket_Blue',
          'Fang_Rust_Bucket_Red',
          'Fang_Rust_Bucket_Violet',
          'Fang_Rust_bucket_Yellow',
          'Fang_Seafoam',
          'Neo_Shogun_24CT_Gold',
          'Neo_Shogun_Assassin',
          'Neo_Shogun_Blub_and_Friends',
          'Neo_Shogun_Ghost_Captain_Blue',
          'Neo_Shogun_Ghost_Captain_Green',
          'Neo_Shogun_Ghost_Captain_Red',
          'Neo_Shogun_Hyper_Pressure',
          'Neo_Shogun_King_Blub',
          'Neo_Shogun_Patrol',
          'Neo_Shogun_Royal_Blue',
          'Neo_Shogun_Rust_Bucket_Blue',
          'Neo_Shogun_Rust_Bucket_Red',
          'Neo_Shogun_Rust_Bucket_Violet',
          'Neo_Shogun_Rust_Bucket_Yellow',
          'Neo_Shogun_Seafoam'
        ],
        numbers: ['1_0002', '2_0001', '3_0000', '4_0003', '5_0004', '6_0005', '7_0006']
      },
      thelm: {
        folders: [
          'THELM_Blub_and_Friends_Silver',
          'THELM_Deep_Sea_Gold',
          'THELM_Ghost_Captain_Blue',
          'THELM_Ghost_Captain_Green',
          'THELM_Helm_Blub_and_Friends_Gold',
          'THELM_Hyper_Pressure',
          'THELM_Hyper_Pressure_Blubsessed',
          'THELM_Hyper_Pressure_Trifecta',
          'THELM_Hyper_Pressure_X',
          'THELM_King_Blub',
          'THELM_Navy_Seal',
          'THELM_RustBucketBlue',
          'THELM_RustBucketRed',
          'THELM_RustBucketViolet',
          'THELM_RustBucketYellow'
        ],
        numbers: ['1_0000', '2_0001', '3_0002', '4_0003', '6_0005', '7_0006']
      }
    };

    /************************************************
     * 3) Build a Grouped Object of All Images
     ************************************************/
    async function getGroupedImages() {
      // Generate all possible paths
      const paths = [];
      Object.values(folderGroups).forEach(group => {
        group.folders.forEach(folder => {
          group.numbers.forEach(num => {
            paths.push(`images/${folder}/${num}.png`);
          });
          // If folder starts with THELM_, add a profile headshot
          if (folder.startsWith('THELM_')) {
            paths.push(`images/${folder}/Profile_Headshot_0004.png`);
          }
        });
      });

      // Group by folder
      const grouped = {};
      for (const path of paths) {
        const parts = path.split('/');
        const folder = parts[parts.length - 2];
        if (!grouped[folder]) grouped[folder] = [];
        grouped[folder].push(path);
      }

      // Sort each folder's images
      for (const folder in grouped) {
        grouped[folder].sort((a, b) => {
          const fileA = a.split('/').pop();
          const fileB = b.split('/').pop();

          // Extract the numeric parts from the filenames
          const matchA = fileA.match(/(\d+)_/);
          const matchB = fileB.match(/(\d+)_/);
          const numA = matchA ? parseInt(matchA[1]) : 0;
          const numB = matchB ? parseInt(matchB[1]) : 0;
          if (numA !== numB) return numA - numB;

          const matchSecA = fileA.match(/_(\d+)\./);
          const matchSecB = fileB.match(/_(\d+)\./);
          const secA = matchSecA ? parseInt(matchSecA[1]) : 0;
          const secB = matchSecB ? parseInt(matchSecB[1]) : 0;
          return secA - secB;
        });
      }

      return grouped;
    }

    /************************************************
     * 4) UI for Folder Selection
     ************************************************/
    let groupedImages = {};   // Holds all images grouped by folder
    let images = [];          // Currently selected folder's images

    function createFolderList(folderNames) {
      const folderListDiv = document.getElementById('folder-list');
      folderListDiv.innerHTML = ''; // Clear any existing buttons

      folderNames.forEach(folder => {
        const btn = document.createElement('button');
        // Display underscores as spaces
        btn.textContent = folder.replace(/_/g, ' ');
        btn.addEventListener('click', () => {
          // Switch to this folder
          images = groupedImages[folder];
          currentIndex = 0;
          loadPhotos();
        });
        folderListDiv.appendChild(btn);
      });
    }

    /************************************************
     * 5) Create Photo Plane (No Custom Shader)
     ************************************************/
    function createPhotoPlane(texture, position) {
      const imageAspect = texture.image.width / texture.image.height;
      const displayWidth = 3;
      const displayHeight = displayWidth / imageAspect;

      const geometry = new THREE.PlaneGeometry(displayWidth, displayHeight);
      // Use a basic material (no dissolve/fade shader)
      const material = new THREE.MeshBasicMaterial({
        map: texture,
        transparent: true
      });

      const plane = new THREE.Mesh(geometry, material);
      plane.position.copy(position);
      plane.userData.baseRotation = plane.rotation.y;
      return plane;
    }

    function getPhotoPosition(t) {
      // Simple arrangement: left = -1, center = 0, right = +1
      // multiplied by some factor for spacing
      const x = t * 4;
      const z = -Math.abs(t) * 2;
      return new THREE.Vector3(x, 0, z);
    }

    // Helper to load a texture with a Promise
    const textureLoader = new THREE.TextureLoader();
    function loadTexture(url) {
      return new Promise((resolve, reject) => {
        textureLoader.load(url, resolve, undefined, reject);
      });
    }

    /************************************************
     * 6) Photo Loading
     ************************************************/
    let photoObjects = [];
    let currentIndex = 0;
    let isAnimating = false;

    async function loadPhotos() {
      // Remove existing photos
      photoObjects.forEach(obj => scene.remove(obj));
      photoObjects = [];

      // If no images in this folder, just return
      if (!images || images.length === 0) return;

      // Indices for prev, current, next
      const indices = [
        (currentIndex - 1 + images.length) % images.length,
        currentIndex,
        (currentIndex + 1) % images.length
      ];

      try {
        const texArray = await Promise.all(indices.map(i => loadTexture(images[i])));
        texArray.forEach((texture, i) => {
          const position = getPhotoPosition(i - 1);
          const photo = createPhotoPlane(texture, position);
          photo.rotation.y = (i - 1) * -0.2;
          photo.userData.baseRotation = photo.rotation.y;
          scene.add(photo);
          photoObjects.push(photo);
        });
      } catch (error) {
        console.error('Error loading textures:', error);
      }
    }

    /************************************************
     * 7) Navigation (Simple Slide, No Fade)
     ************************************************/
    function animateTransition(direction) {
      if (isAnimating) return;
      isAnimating = true;

      const duration = 1.0;
      const tl = gsap.timeline({
        onComplete: () => {
          isAnimating = false;
          currentIndex = (currentIndex + direction + images.length) % images.length;
          loadPhotos();
        }
      });

      // Slide the three planes left/right
      [photoObjects[0], photoObjects[1], photoObjects[2]].forEach((photo, i) => {
        if (!photo) return;
        const posIndex = i - 1; // -1, 0, 1
        const targetPos = getPhotoPosition(posIndex - direction);
        const targetRot = (posIndex - direction) * -0.2;

        tl.to(photo.position, {
          x: targetPos.x,
          y: targetPos.y,
          z: targetPos.z,
          duration: duration,
          ease: "power2.inOut"
        }, 0);

        tl.to(photo.rotation, {
          y: targetRot,
          duration: duration,
          ease: "power2.inOut"
        }, 0);
      });
    }

    function navigate(direction) {
      if (!isAnimating) {
        animateTransition(direction);
      }
    }

    /************************************************
     * 8) Interaction (Mouse, Click, Keys)
     ************************************************/
    let mouseX = 0;
    let mouseY = 0;

    // Subtle parallax rotation with mouse
    document.addEventListener('mousemove', event => {
      mouseX = (event.clientX - window.innerWidth / 2) / 200;
      mouseY = (event.clientY - window.innerHeight / 2) / 200;
    });

    // Click left or right side of the screen to navigate
    renderer.domElement.addEventListener('click', event => {
      const x = event.clientX / window.innerWidth;
      if (x < 0.3) navigate(-1);
      else if (x > 0.7) navigate(1);
    });

    // Keyboard arrow navigation
    document.addEventListener('keydown', event => {
      if (event.key === 'ArrowLeft') navigate(-1);
      if (event.key === 'ArrowRight') navigate(1);
    });

    /************************************************
     * 9) Animation Loop
     ************************************************/
    function animate() {
      requestAnimationFrame(animate);

      photoObjects.forEach(photo => {
        if (!photo) return;
        // Combine base rotation with mouse offset
        photo.rotation.y = photo.userData.baseRotation + mouseX * 0.05;
        photo.rotation.x = mouseY * 0.05;
      });

      renderer.render(scene, camera);
    }

    /************************************************
     * 10) Resize Handling
     ************************************************/
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    /************************************************
     * 11) Initialize Everything
     ************************************************/
    async function init() {
      groupedImages = await getGroupedImages();
      const folderNames = Object.keys(groupedImages).sort();
      createFolderList(folderNames);

      // Default to the first folder in the list (if any)
      if (folderNames.length > 0) {
        images = groupedImages[folderNames[0]];
        currentIndex = 0;
        loadPhotos();
      }
    }

    init();
    animate();
  </script>
</body>
</html>
