<!DOCTYPE html>
<html>
<head>
  <title>Image Viewer</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- Three.js and GSAP libraries -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
  <style>
    body { 
      margin: 0;
      overflow: hidden;
      background: #000;
    }
  </style>
</head>
<body>
  <script>
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Shader code
    const dissolveVertexShader = `
      varying vec2 vUv;
      void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `;

    const dissolveFragmentShader = `
      uniform sampler2D tDiffuse;
      uniform float dissolve;
      uniform float pixelSize;
      varying vec2 vUv;

      float random(vec2 co) {
          return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
      }

      void main() {
          vec2 pixelatedUV = floor(vUv * pixelSize) / pixelSize;
          float r = random(pixelatedUV);
          float fallStart = r * 0.3;
          float fallProgress = max(0.0, (dissolve - fallStart) / (1.0 - fallStart));
          float gravity = fallProgress * fallProgress * 0.0001;
          vec2 offsetUV = vUv;
          offsetUV.y -= gravity;
          vec4 color = texture2D(tDiffuse, offsetUV);
          float fade = 1.0 - fallProgress;
          if(offsetUV.y < 0.0 || offsetUV.y > 1.0) {
              fade = 0.0;
          }
          float visibility = step(dissolve, r) + (1.0 - step(fallStart, dissolve)) * fade;
          gl_FragColor = vec4(color.rgb, visibility * color.a);
      }
    `;

    let currentIndex = 0;
    let isAnimating = false;
    const photoObjects = [];
    const textureLoader = new THREE.TextureLoader();

    // Function to scan the images directory using defined folder groups and naming patterns.
    async function getImagePaths() {
      const folderGroups = {
        fangAndNeo: {
          folders: [
            'Fang_24CT_Gold',
            'Fang_Assassin',
            'Fang_Blub_and_Friends',
            'Fang_Ghost_Captain_Blue',
            'Fang_Ghost_Captain_Green',
            'Fang_Ghost_Captain_Red',
            'Fang_Hyper_Pressure',
            'Fang_King_Blub',
            'Fang_Patrol',
            'Fang_Royal_Blue',
            'Fang_Rust_Bucket_Blue',
            'Fang_Rust_Bucket_Red',
            'Fang_Rust_Bucket_Violet',
            'Fang_Rust_Bucket_Yellow',
            'Fang_Seafoam',
            'Neo_Shogun_24CT_Gold',
            'Neo_Shogun_Assassin',
            'Neo_Shogun_Blub_and_Friends',
            'Neo_Shogun_Ghost_Captain_Blue',
            'Neo_Shogun_Ghost_Captain_Green',
            'Neo_Shogun_Ghost_Captain_Red',
            'Neo_Shogun_Hyper_Pressure',
            'Neo_Shogun_King_Blub',
            'Neo_Shogun_Patrol',
            'Neo_Shogun_Royal_Blue',
            'Neo_Shogun_Rust_Bucket_Blue',
            'Neo_Shogun_Rust_Bucket_Red',
            'Neo_Shogun_Rust_Bucket_Violet',
            'Neo_Shogun_Rust_Bucket_Yellow',
            'Neo_Shogun_Seafoam'
          ],
          numbers: ['1_002', '2_001', '3_000', '4_003', '5_004', '6_005', '7_006']
        },
        thelm: {
          folders: [
            'THELM_Blub_and_Friends_Silver',
            'THELM_Deep_Sea_Gold',
            'THELM_Ghost_Captain_Blue',
            'THELM_Ghost_Captain_Green',
            'THELM_Helm_Blub_and_Friends_Gold',
            'THELM_Hyper_Pressure',
            'THELM_Hyper_Pressure_Blubsessed',
            'THELM_Hyper_Pressure_Trifecta',
            'THELM_Hyper_Pressure_X',
            'THELM_King_Blub',
            'THELM_Navy_Seal',
            'THELM_RustBucketBlue',
            'THELM_RustBucketRed',
            'THELM_RustBucketViolet',
            'THELM_RustBucketYellow'
          ],
          numbers: ['1_0000', '2_0001', '3_0002', '4_0003', '6_0005', '7_0006']
        }
      };

      const paths = [];

      // Generate paths for each folder group.
      Object.values(folderGroups).forEach(group => {
        group.folders.forEach(folder => {
          group.numbers.forEach(num => {
            paths.push(`images/${folder}/${num}.png`);
          });
          // For THELM folders, add a profile headshot.
          if (folder.startsWith('THELM_')) {
            paths.push(`images/${folder}/Profile_Headshot_0004.png`);
          }
        });
      });

      return paths;
    }

    // Sort images by grouping them by folder and then by filename number.
    function sortImages(imageList) {
      const groupedImages = {};
      imageList.forEach(imagePath => {
        const parts = imagePath.split('/');
        const folder = parts[parts.length - 2];
        if (!groupedImages[folder]) {
          groupedImages[folder] = [];
        }
        groupedImages[folder].push(imagePath);
      });

      const sortedFolders = Object.keys(groupedImages).sort();

      sortedFolders.forEach(folder => {
        groupedImages[folder].sort((a, b) => {
          const fileA = a.split('/').pop();
          const fileB = b.split('/').pop();
          
          const matchA = fileA.match(/(\d+)_/);
          const matchB = fileB.match(/(\d+)_/);
          const numA = matchA ? parseInt(matchA[1]) : 0;
          const numB = matchB ? parseInt(matchB[1]) : 0;
          if (numA !== numB) return numA - numB;
          
          const matchSecA = fileA.match(/_(\d+)\./);
          const matchSecB = fileB.match(/_(\d+)\./);
          const secA = matchSecA ? parseInt(matchSecA[1]) : 0;
          const secB = matchSecB ? parseInt(matchSecB[1]) : 0;
          return secA - secB;
        });
      });

      const sortedImages = [];
      sortedFolders.forEach(folder => {
        groupedImages[folder].forEach(filepath => {
          sortedImages.push(filepath);
        });
      });

      return sortedImages;
    }

    // Create a photo plane with a custom shader material that applies the dissolve effect.
    function createPhotoPlane(texture, position) {
      const imageAspect = texture.image.width / texture.image.height;
      const displayWidth = 3;
      const displayHeight = displayWidth / imageAspect;
      
      const geometry = new THREE.PlaneGeometry(displayWidth, displayHeight);
      const material = new THREE.ShaderMaterial({
        uniforms: {
          tDiffuse: { value: texture },
          dissolve: { value: 0.0 },
          pixelSize: { value: 50.0 }
        },
        vertexShader: dissolveVertexShader,
        fragmentShader: dissolveFragmentShader,
        transparent: true
      });
      
      const plane = new THREE.Mesh(geometry, material);
      plane.position.copy(position);
      // Save the base rotation for combining GSAP animations with mouse input.
      plane.userData.baseRotation = plane.rotation.y;
      return plane;
    }

    // Compute the position of a photo based on a parameter t.
    function getPhotoPosition(t) {
      const x = t * 4;
      const z = -Math.abs(t) * 2;
      return new THREE.Vector3(x, 0, z);
    }

    // Helper: Load a texture using a promise.
    function loadTexturePromise(url) {
      return new Promise((resolve, reject) => {
        textureLoader.load(url, resolve, undefined, reject);
      });
    }

    // Load the three photos (previous, current, next) and add them to the scene.
    async function loadPhotos() {
      // Remove existing photos.
      photoObjects.forEach(obj => scene.remove(obj));
      photoObjects.length = 0;

      const indices = [
        (currentIndex - 1 + images.length) % images.length,
        currentIndex,
        (currentIndex + 1) % images.length
      ];

      try {
        const textures = await Promise.all(indices.map(index => loadTexturePromise(images[index])));
        textures.forEach((texture, i) => {
          const position = getPhotoPosition(i - 1);
          const photo = createPhotoPlane(texture, position);
          photo.rotation.y = (i - 1) * -0.2;
          photo.userData.baseRotation = photo.rotation.y; // Set the initial base rotation.
          scene.add(photo);
          photoObjects.push(photo);
        });
      } catch (error) {
        console.error('Error loading textures:', error);
      }
    }

    // Animate the transition when navigating between images.
    function animateTransition(direction) {
      if (isAnimating) return;
      isAnimating = true;

      const duration = 1.5;
      const tl = gsap.timeline({
        onComplete: () => {
          isAnimating = false;
          currentIndex = (currentIndex + direction + images.length) % images.length;
          loadPhotos();
        }
      });

      // Apply dissolve effect on the center photo.
      if (photoObjects[1]) {
        tl.to(photoObjects[1].material.uniforms.dissolve, {
          value: 1.0,
          duration: duration * 0.5,
          ease: "power1.in"
        }, 0);
      }

      // Animate side photos (left and right) to new positions and rotations.
      [photoObjects[0], photoObjects[2]].forEach((photo, i) => {
        if (!photo) return;
        
        const posIndex = (i === 0 ? 0 : 2);
        const targetPos = getPhotoPosition(posIndex - 1 - direction);
        const targetRot = (posIndex - 1 - direction) * -0.2;

        tl.to(photo.position, {
          x: targetPos.x,
          y: targetPos.y,
          z: targetPos.z,
          duration: duration,
          ease: "power2.inOut"
        }, 0);

        // Animate the baseRotation property so mouse offset can be added later.
        tl.to(photo.userData, {
          baseRotation: targetRot,
          duration: duration,
          ease: "power2.inOut"
        }, 0);
      });
    }

    // Initialize
    let images = [];
    async function initViewer() {
      camera.position.z = 5;
      images = await getImagePaths();
      images = sortImages(images);
      loadPhotos();
    }

    // Mouse movement handling to add a subtle parallax effect.
    let mouseX = 0;
    let mouseY = 0;
    document.addEventListener('mousemove', (event) => {
      mouseX = (event.clientX - window.innerWidth / 2) / 200;
      mouseY = (event.clientY - window.innerHeight / 2) / 200;
    });

    // Navigation controls via mouse clicks.
    renderer.domElement.addEventListener('click', (event) => {
      const x = event.clientX / window.innerWidth;
      if (x < 0.3) navigate(-1);
      else if (x > 0.7) navigate(1);
    });

    // Navigation controls via arrow keys.
    document.addEventListener('keydown', (event) => {
      if (event.key === 'ArrowLeft') navigate(-1);
      if (event.key === 'ArrowRight') navigate(1);
    });

    function navigate(direction) {
      if (!isAnimating) {
        animateTransition(direction);
      }
    }

    // Animation loop: Update photo rotations with mouse offsets.
    function animate() {
      requestAnimationFrame(animate);
      photoObjects.forEach(photo => {
        if (photo) {
          // Combine the base rotation (controlled by GSAP) with mouse offset.
          photo.rotation.y = photo.userData.baseRotation + mouseX * 0.05;
          photo.rotation.x = mouseY * 0.05;
        }
      });
      renderer.render(scene, camera);
    }

    // Adjust scene on window resize.
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Start the viewer.
    initViewer();
    animate();
  </script>
</body>
</html>
